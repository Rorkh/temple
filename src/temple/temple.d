/**
 * Temple (C) Dylan Knutson, 2013, distributed under the:
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 */

module temple.temple;
private import
  temple.util,
  temple.delims;

public import
	temple.temple,
	temple.temple_context,
	temple.output_stream;

import
  std.array,
  std.exception,
  std.conv,
  std.algorithm,
  std.range,
  std.string;

string gen_temple_func_string(string temple_str, string temple_name = "InlineTemplate")
{
	auto function_str = "";
	auto indent_level = 0;
	size_t line_number = 0;

	void push_line(string[] stmts...)
	{
		foreach(i; 0..indent_level)
		{
			function_str ~= '\t';
		}
		foreach(stmt; stmts)
		{
			function_str ~= stmt;
		}
		function_str ~= '\n';
	}

	void push_linenum()
	{
		push_line(`#line ` ~ (line_number + 1).to!string ~ ` "` ~ temple_name ~ `"`);
	}

	void push_string_literal(string str)
	{
		if(str.length == 0)
			return;

		push_line(`__buff.put("` ~ str.escapeQuotes() ~ `");`);
	}

	void indent()  { indent_level++; }
	void outdent() { indent_level--; }

	// Generates temporary variable names for storing block contents
	// Returns the most recently generated temporary buffer variable name
	string[] tmp_buffer_var_names;
	auto curr_buffer_num = 0;
	string popTmpBufferVar()
	{
		auto name = tmp_buffer_var_names[$-1];
		tmp_buffer_var_names.length--;
		return name;
	}
	void pushTmpBufferVar(string name)
	{
		tmp_buffer_var_names ~= name;
	}
	string newTmpBufferVar()
	{
		auto name = "__buff_tmp_" ~ curr_buffer_num.to!string;
		curr_buffer_num++;
		pushTmpBufferVar(name);
		return name;
	}
	bool hasTmpBufferVar()
	{
		return tmp_buffer_var_names.length != 0;
	}

	// Tracks if the block that the parser has just
	// finished processing should be printed (e.g., is
	// it the block who's contents are assigned to the last tmp_buffer_var)
	bool[] printStartBlockTracker;
	void sawBlockStart(bool will_be_printed)
	{
		printStartBlockTracker ~= will_be_printed;
	}
	bool sawBlockEnd()
	{
		auto will_be_printed = printStartBlockTracker[$-1];
		printStartBlockTracker.length--;
		return will_be_printed;
	}

	//string peekTmpBufferVar()
	//{
	//	return tmp_buffer_var_names[$-1];
	//}

	push_line(`static void Temple(OutputStream __buff, TempleContext __context = null) {`);
	//push_line(`{`);
	//indent();
	push_line(q{
	if(__context is null)
	{
		__context = new TempleContext();
	}

	OutputStream[] __buffers;
	void __pushBuff(OutputStream __new_buff)
	{
		__buffers ~= __buff;
		__buff = __new_buff;
	}

	void __popBuff()
	{
		__buff = __buffers[$-1];
		__buffers.length--;
	}

	__context.pushTemplateHooks(&__pushBuff, &__popBuff);
	scope(exit) { __context.popTemplateHooks(); }

	import std.conv : to;
	__buff.put("");
	});

	indent();
	push_line(`with(__context) {`);
	indent();

	auto safeswitch = 0;

	string prevTempl = "";

	while(!temple_str.empty) {
		if(safeswitch++ > 100) {
			assert(false, "nesting level too deep; throwing saftey switch: \n" ~ temple_str);
		}

		DelimPos!(OpenDelim)* oDelimPos = temple_str.nextDelim(OpenDelims);

		if(oDelimPos is null)
		{
			//No more delims; append the rest as a string
			push_linenum();
			push_string_literal(temple_str);
			prevTempl.munchHeadOf(temple_str, temple_str.length);
		}
		else
		{
			immutable OpenDelim  oDelim = oDelimPos.delim;
			immutable CloseDelim cDelim = OpenToClose[oDelim];

			if(oDelimPos.pos == 0)
			{
				if(oDelim.isShort())
				{
					if(!prevTempl.validBeforeShort())
					{
						// Chars before % weren't all whitespace, assume it's part of a
						// string literal.
						push_linenum();
						push_string_literal(temple_str[0..oDelim.toString().length]);
						prevTempl.munchHeadOf(temple_str, oDelim.toString().length);
						continue;
					}
				}

				// If we made it this far, we've got valid open/close delims
				auto cDelimPos = temple_str.nextDelim([cDelim]);
				if(cDelimPos is null)
				{
					if(oDelim.isShort())
					{
						// don't require a short close delim at the end of the template
						temple_str ~= cDelim.toString();
						cDelimPos = enforce(temple_str.nextDelim([cDelim]));
					}
					else
					{
						assert(false, "Missing close delimer: " ~ cDelim.toString());
					}
				}

				// Made it this far, we've got the position of the close delimer.
				push_linenum();
				auto inbetween_delims = temple_str[oDelim.toString().length .. cDelimPos.pos];

				// track block starts
				immutable bool is_block_start = inbetween_delims.isBlockStart();
				immutable bool is_block_end   = inbetween_delims.isBlockEnd();
				assert(!(is_block_start && is_block_end), "Internal bug: " ~ inbetween_delims);

				if(is_block_start)
				{
					sawBlockStart(oDelim.isStr());
				}

				if(oDelim.isStr())
				{
					// Check if this is a block; in that case, put the block's
					// contents into a temporary variable, then render that
					// variable after the block close delim

					// The line would look like:
					// <%= capture(() { %>
					//  <% }); %>
					// so look for something like "){" or ") {" at the end

					if(is_block_start)
					{
						string tmp_buffer_var = newTmpBufferVar();
						push_line(`auto %s =%s`.format(tmp_buffer_var, inbetween_delims));
						indent();
					}
					else
					{
						push_line(`__buff.put(to!string(` ~ inbetween_delims ~ `));`);
						if(cDelim == CloseDelim.CloseShort)
						{
							push_line(`__buff.put("\n");`);
						}
					}
				}
				else
				{
					// It's just raw code, push it into the function body
					push_line(inbetween_delims);

					// Check if the code looks like the ending to a block;
					// e.g. for block:
					// <%= capture(() { %>
					// <% }); %>`
					// look for it starting with }<something>);
					// If it does, output the last tmp buffer var on the stack
					if(is_block_end && hasTmpBufferVar)
					{

						// the block at this level should be printed
						if(sawBlockEnd())
						{
							outdent();
							push_line(`__buff.put(%s);`.format(popTmpBufferVar()));
						}
					}
				}

				// remove up to the closing delimer
				prevTempl.munchHeadOf(
					temple_str,
					cDelimPos.pos + cDelim.toString().length);
			}
			else
			{
				// Move ahead to the next open delimer, rendering
				// everything between here and there as a string literal
				push_linenum();
				immutable delim_pos = oDelimPos.pos;
				push_string_literal(temple_str[0..delim_pos]);
				prevTempl.munchHeadOf(temple_str, delim_pos);
			}
		}

		// count the number of newlines in the previous part of the template;
		// that's the current line number
		line_number = prevTempl.count('\n');
	}

	outdent();
	push_line("}");
	outdent();
	push_line("}");

	return function_str;
}

template Temple(string template_string, string temple_name)
{
	//pragma(msg, gen_temple_func_string(template_string, temple_name));
	mixin(gen_temple_func_string(template_string, temple_name));
	#line 303 "src/temple/temple.d"
}

template Temple(string template_string)
{
	//pragma(msg, gen_temple_func_string(template_string));
	mixin(gen_temple_func_string(template_string));
	#line 310 "src/temple/temple.d"
}

alias TempleFuncType = typeof(Temple!"");

template TempleFile(string template_file)
{
	pragma(msg, "Compiling ", template_file, "...");
	alias TempleFile = Temple!(import(template_file), template_file);
}

template TempleLayout(string template_string)
{
	alias layout_renderer = Temple!template_string;
	alias TempleLayout = TempleLayoutImpl!layout_renderer;
}

template TempleLayoutFile(string template_file)
{
	alias layout_renderer = TempleFile!template_file;
	alias TempleLayoutFile = TempleLayoutImpl!layout_renderer;
}

void TempleLayoutImpl(alias layout_renderer)(
	OutputStream buff,
	TempleFuncType* temple_func,
	TempleContext context = null)
{
	if(context is null)
	{
		context = new TempleContext();
	}

	auto old_partial = context.partial;
	context.partial = temple_func;
	scope(exit)
	{
		context.partial = old_partial;
	}

	layout_renderer(buff, context);
}

alias TempleLayoutFuncType = typeof(TempleLayoutImpl!(Temple!""));

/**
 * Helper functions for quicly rendering a template as a string
 */

string templeToString(TempleFuncType* func, TempleContext context = null)
{
	auto accum = new AppenderOutputStream;
	(*func)(accum, context);
	return accum.data;
}

string templeToString(TempleLayoutFuncType* layout, TempleFuncType* partial, TempleContext context = null)
{
	auto accum = new AppenderOutputStream;
	(*layout)(accum, partial, context);
	return accum.data;
}


version(unittest)
{
	private import std.stdio, std.file : readText;

	bool isSameRender(string r1, string r2)
	{
		auto ret = r1.stripWs == r2.stripWs;

		if(ret == false)
		{
			writeln("Renders differ: ");
			writeln("------------------------------");
			writeln(r1);
			writeln("------------------------------");
			writeln(r2);
			writeln("------------------------------");
		}

		return ret;
	}
}

unittest
{
	alias render = Temple!"";
	auto accum = new AppenderOutputStream;

	render(accum);
	assert(accum.data == "");
}

unittest
{
	//Test to!string of eval delimers
	alias render = Temple!`<%= "foo" %>`;
	assert(templeToString(&render) == "foo");
}

unittest
{
	// Test delimer parsing
	alias render = Temple!("<% if(true) { %>foo<% } %>");
	assert(templeToString(&render) == "foo");
}
unittest
{
	//Test raw text with no delimers
	alias render = Temple!(`foo`);
	assert(templeToString(&render) == "foo");
}

unittest
{
	//Test looping
	const templ = `<% foreach(i; 0..3) { %>foo<% } %>`;
	alias render = Temple!templ;
	assert(templeToString(&render) == "foofoofoo");
}

unittest
{
	//Test looping
	const templ = `<% foreach(i; 0..3) { %><%= i %><% } %>`;
	alias render = Temple!templ;
	assert(templeToString(&render) == "012");
}

unittest
{
	//Test escaping of "
	const templ = `"`;
	alias render = Temple!templ;
	assert(templeToString(&render) == `"`);
}

unittest
{
	//Test escaping of '
	const templ = `'`;
	alias render = Temple!templ;
	assert(templeToString(&render) == `'`);
}

unittest
{
	alias render = Temple!`"%"`;
	assert(templeToString(&render) == `"%"`);
}

unittest
{
	// Test shorthand
	const templ = `
		% if(true) {
			Hello!
		% }
	`;
	alias render = Temple!(templ);
	assert(isSameRender(templeToString(&render), "Hello!"));
}

unittest
{
	// Test shorthand string eval
	const templ = `
		% if(true) {
			%= "foo"
		% }
	`;
	alias render = Temple!(templ);
	assert(isSameRender(templeToString(&render), "foo"));
}
unittest
{
	// Test shorthand only after newline
	const templ = `foo%bar`;
	alias render = Temple!(templ);
	assert(templeToString(&render) == "foo%bar");
}

unittest
{
	// Ditto
	alias render = Temple!`<%= "foo%bar" %>`;
	assert(templeToString(&render) == "foo%bar");
}

unittest
{
	auto context = new TempleContext();
	context.foo = 123;
	context.bar = "test";

	alias render = Temple!`<%= var("foo") %> <%= var("bar") %>`;
	assert(templeToString(&render, context) == "123 test");
}

unittest
{
	// Loading templates from a file
	alias render = TempleFile!"test1.emd";
	auto compare = readText("test/test1.emd.txt");
	assert(isSameRender(templeToString(&render), compare));
}

unittest
{
	alias render = TempleFile!"test2.emd";
	auto compare = readText("test/test2.emd.txt");

	auto ctx = new TempleContext();
	ctx.name = "dymk";
	ctx.will_work = true;

	assert(isSameRender(templeToString(&render, ctx), compare));
}

unittest
{
	alias render = TempleFile!"test3_nester.emd";
	auto compare = readText("test/test3.emd.txt");
	assert(isSameRender(templeToString(&render), compare));
}

unittest
{
	alias render = TempleFile!"test4_root.emd";
	auto compare = readText("test/test4.emd.txt");

	auto ctx = new TempleContext();
	ctx.var1 = "this_is_var1";

	assert(isSameRender(templeToString(&render, ctx), compare));
}

unittest
{
	alias render = Temple!"before <%= yield %> after";
	alias partial = Temple!"between";
	auto accum = new AppenderOutputStream;

	auto context = new TempleContext();
	context.partial = &partial;

	render(accum, context);
	assert(isSameRender(accum.data, "before between after"));
}

unittest
{
	alias layout = TempleLayout!"before <%= yield %> after";
	alias partial = Temple!"between";
	auto accum = new AppenderOutputStream;

	layout(accum, &partial);

	assert(isSameRender(accum.data, "before between after"));
}

unittest
{
	alias layout = TempleLayoutFile!"test5_layout.emd";
	alias partial1 = TempleFile!"test5_partial1.emd";
	alias partial2 = TempleFile!"test5_partial2.emd";

	auto accum = new AppenderOutputStream;

	layout(accum, &partial1);

	assert(isSameRender(accum.data, readText("test/test5_partial1.emd.txt")));

	accum.clear;
	layout(accum, &partial2);
	assert(isSameRender(accum.data, readText("test/test5_partial2.emd.txt")));
}

// Layouts and contexts
unittest
{
	alias layout = TempleLayoutFile!"test6_layout.emd";
	alias partial = TempleFile!"test6_partial.emd";
	auto accum = new AppenderOutputStream;
	auto context = new TempleContext();

	context.name = "dymk";
	context.uni = "UCSD";
	context.age = 18;

	layout(accum, &partial, context);
	assert(isSameRender(accum.data, readText("test/test6_partial.emd.txt")));
}

// opDispatch variable getting
unittest
{
	alias render = Temple!"<%= var.foo %>";
	auto accum = new AppenderOutputStream;
	auto context = new TempleContext();

	context.foo = "Hello, world";

	render(accum, context);
	assert(accum.data == "Hello, world");
}

unittest
{
	// Uncomment to view the line numbers inserted into the template
	//alias render = TempleFile!"test7_error.emd";
	assert(!__traits(compiles, TempleFile!"test7_error.emd"));
}

unittest
{
	// test captures
	alias render = Temple!q{
		<% auto a = capture(() { %>
			This is captured in A
		<% }); %>
		<% auto b = capture(() { %>
			This is captured in B
		<% }); %>

		B said: "<%= b %>"
		A said: "<%= a %>"
	};

	auto accum = new AppenderOutputStream;
	render(accum);

	assert(isSameRender(accum.data, `
		B said: "This is captured in B"
		A said: "This is captured in A"
	`));
}

unittest
{
	// Nested captures
	alias render = Temple!q{
		<% auto outer = capture(() { %>
			Outer, first
			<% auto inner = capture(() { %>
				Inner, first
			<% }); %>
			Outer, second

			<%= inner %>
		<% }); %>

		<%= outer %>
	};

	auto accum = new AppenderOutputStream;
	render(accum);

	assert(isSameRender(accum.data, `
		Outer, first
		Outer, second
			Inner, first
	`));
}

unittest
{
	alias render = TempleFile!"test8_building_helpers.emd";
	assert(isSameRender(templeToString(&render), readText("test/test8_building_helpers.emd.txt")));
}

unittest
{
	alias render = Temple!q{
		<%= capture(() { %>
			directly printed

			<% auto a = capture(() { %>
				a, captured
			<% }); %>
			<% auto b = capture(() { %>
				b, captured
			<% }); %>

			<%= a %>
			<%= capture(() { %>
				directly printed from a nested capture
			<% }); %>
			<%= b %>

		<% }); %>
	};

	auto accum = new AppenderOutputStream;
	render(accum);

	assert(isSameRender(accum.data, `
		directly printed
			a, captured
			directly printed from a nested capture
			b, captured`));
}

/**
 * Test CTFE compatibility
 */
unittest
{
	alias render = Temple!q{ <%= "foo" %> };
	const result = templeToString(&render);
	static assert(isSameRender(result, "foo"));
}

unittest
{
	alias render = Temple!q{
		<% if(true) { %>
			Bort
		<% } else { %>
			No bort!
		<% } %>

		<% auto a = capture(() { %>
			inside a capture block
		<% }); %>

		Before capture
		<%= a %>
		After capture
	};

	const result = templeToString(&render);
	static assert(isSameRender(result, `
		Bort
		Before capture
		inside a capture block
		After capture
	`));
}

// std.variant needs to be made CTFE compatible
version(none)
unittest
{
	alias render = Temple!q{
		Name: <%= var.name %>
		Number: <%= var.number %>

		<% auto captured = capture(() { %>
			Here is some captured content!
			var.name: <%= var.name %>
		<% }); %>
		<%= captured %>

		<%= capture(() { %>
			A capture directly being rendered, for completeness.
		<% }); %>
	};

	// The lambda is a hack to set up a temple context
	// at compile time, using a self executing function literal

	const result = templeToString(&render, (() {
		auto ctx = new TempleContext;
		ctx.name = "dymk";
		ctx.number = 1234;
		return ctx;
	})() );

	static assert(isSameRender(result, `
		Name: dymk
		Number: 1234
			Here is some captured content!
			var.name: dymk
		A capture directly being rendered, for completeness.
	`));
}
