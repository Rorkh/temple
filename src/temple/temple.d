/**
 * Temple (C) Dylan Knutson, 2013, distributed under the:
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 */

module temple.temple;
private import
  temple.util,
  temple.delims;

public import
	temple.temple,
	temple.temple_context,
	temple.output_stream;

import
  std.array,
  std.exception,
  std.conv,
  std.algorithm,
  std.range,
  std.string;

string gen_temple_func_string(string temple_str, string temple_name, string filter_policy_ident = "")
{
	auto function_str = "";
	auto indent_level = 0;
	size_t line_number = 0;

	void push_line(string[] stmts...)
	{
		foreach(i; 0..indent_level)
		{
			function_str ~= '\t';
		}
		foreach(stmt; stmts)
		{
			function_str ~= stmt;
		}
		function_str ~= '\n';
	}

	void push_linenum()
	{
		push_line(`#line ` ~ (line_number + 1).to!string ~ ` "` ~ temple_name ~ `"`);
	}

	void push_string_literal(string str)
	{
		if(str.length == 0)
			return;

		push_line(`__buff.put("` ~ str.escapeQuotes() ~ `");`);
	}

	void indent()  { indent_level++; }
	void outdent() { indent_level--; }

	// Generates temporary variable names for storing block contents
	// Returns the most recently generated temporary buffer variable name
	string[] tmp_buffer_var_names;
	auto curr_buffer_num = 0;
	string popTmpBufferVar()
	{
		auto name = tmp_buffer_var_names[$-1];
		tmp_buffer_var_names.length--;
		return name;
	}
	void pushTmpBufferVar(string name)
	{
		tmp_buffer_var_names ~= name;
	}
	string newTmpBufferVar()
	{
		auto name = "__buff_tmp_" ~ curr_buffer_num.to!string;
		curr_buffer_num++;
		pushTmpBufferVar(name);
		return name;
	}
	bool hasTmpBufferVar()
	{
		return tmp_buffer_var_names.length != 0;
	}

	// Tracks if the block that the parser has just
	// finished processing should be printed (e.g., is
	// it the block who's contents are assigned to the last tmp_buffer_var)
	bool[] printStartBlockTracker;
	void sawBlockStart(bool will_be_printed)
	{
		printStartBlockTracker ~= will_be_printed;
	}
	bool sawBlockEnd()
	{
		auto will_be_printed = printStartBlockTracker[$-1];
		printStartBlockTracker.length--;
		return will_be_printed;
	}

	string function_type_params = "";
	if(filter_policy_ident.length)
	{
		function_type_params = "(%s)".format(filter_policy_ident);
	}
	push_line(`static void TempleFunc%s(OutputStream __buff, TempleContext __context = null) {`.format(function_type_params));
	//push_line(`{`);
	//indent();

	push_line(q{
		// Why isn't this just an overload of __buffFilteredPut?
		// Because D doesn't allow overloading of nested functions
		void __buffPutStream(AppenderOutputStream os)
		{
			__buff.put(os.data);
		}
	});

	if(filter_policy_ident.length)
	{
		push_line(q{
			void __buffFilteredPut(T)(T thing)
			{
				__buff.put(%s.templeFilter(thing));
			}
		}.format(filter_policy_ident));
	}
	else
	{
		// No filter policy means just directly append the thing to the
		// buffer
		push_line(q{
			void __buffFilteredPut(T)(T thing)
			{
				import std.conv : to;
				__buff.put(thing.to!string);
			}
		});
	}

	push_line(q{

		if(__context is null)
		{
			__context = new TempleContext();
		}

		OutputStream[] __buffers;
		void __pushBuff(OutputStream __new_buff)
		{
			__buffers ~= __buff;
			__buff = __new_buff;
		}

		void __popBuff()
		{
			__buff = __buffers[$-1];
			__buffers.length--;
		}

		__context.pushTemplateHooks(&__pushBuff, &__popBuff);
		scope(exit) { __context.popTemplateHooks(); }

		import std.conv : to;
		__buff.put("");

	});

	indent();
	if(filter_policy_ident.length)
	{
		push_line(`with(%s)`.format(filter_policy_ident));
	}
	push_line(`with(__context) {`);
	indent();

	auto safeswitch = 0;

	string prevTempl = "";

	while(!temple_str.empty) {
		if(safeswitch++ > 100) {
			assert(false, "nesting level too deep; throwing saftey switch: \n" ~ temple_str);
		}

		DelimPos!(OpenDelim)* oDelimPos = temple_str.nextDelim(OpenDelims);

		if(oDelimPos is null)
		{
			//No more delims; append the rest as a string
			push_linenum();
			push_string_literal(temple_str);
			prevTempl.munchHeadOf(temple_str, temple_str.length);
		}
		else
		{
			immutable OpenDelim  oDelim = oDelimPos.delim;
			immutable CloseDelim cDelim = OpenToClose[oDelim];

			if(oDelimPos.pos == 0)
			{
				if(oDelim.isShort())
				{
					if(!prevTempl.validBeforeShort())
					{
						// Chars before % weren't all whitespace, assume it's part of a
						// string literal.
						push_linenum();
						push_string_literal(temple_str[0..oDelim.toString().length]);
						prevTempl.munchHeadOf(temple_str, oDelim.toString().length);
						continue;
					}
				}

				// If we made it this far, we've got valid open/close delims
				auto cDelimPos = temple_str.nextDelim([cDelim]);
				if(cDelimPos is null)
				{
					if(oDelim.isShort())
					{
						// don't require a short close delim at the end of the template
						temple_str ~= cDelim.toString();
						cDelimPos = enforce(temple_str.nextDelim([cDelim]));
					}
					else
					{
						assert(false, "Missing close delimer: " ~ cDelim.toString());
					}
				}

				// Made it this far, we've got the position of the close delimer.
				push_linenum();
				auto inbetween_delims = temple_str[oDelim.toString().length .. cDelimPos.pos];

				// track block starts
				immutable bool is_block_start = inbetween_delims.isBlockStart();
				immutable bool is_block_end   = inbetween_delims.isBlockEnd();
				assert(!(is_block_start && is_block_end), "Internal bug: " ~ inbetween_delims);

				if(is_block_start)
				{
					sawBlockStart(oDelim.isStr());
				}

				if(oDelim.isStr())
				{
					// Check if this is a block; in that case, put the block's
					// contents into a temporary variable, then render that
					// variable after the block close delim

					// The line would look like:
					// <%= capture(() { %>
					//  <% }); %>
					// so look for something like "){" or ") {" at the end

					if(is_block_start)
					{
						string tmp_buffer_var = newTmpBufferVar();
						push_line(`auto %s =%s`.format(tmp_buffer_var, inbetween_delims));
						indent();
					}
					else
					{
						// A hack because D doesn't support overloading
						// nested functions, so the thing being pushed
						// has to be manually be passed to the right
						// buffer append function
						// Comparing typeof().stringof to another string is another hack...
						// is(typeof(__expr__) == AppenderOutputStream) always returns false
						push_line(q{
							static if(is(typeof(__expr__) == AppenderOutputStream))
							{
								__buffPutStream(__expr__);
							}
							else
							{
								__buffFilteredPut(__expr__);
							}
						}.replace("__expr__", inbetween_delims));

						if(cDelim == CloseDelim.CloseShort)
						{
							push_line(`__buffFilteredPut("\n");`);
						}
					}
				}
				else
				{
					// It's just raw code, push it into the function body
					push_line(inbetween_delims);

					// Check if the code looks like the ending to a block;
					// e.g. for block:
					// <%= capture(() { %>
					// <% }); %>`
					// look for it starting with }<something>);
					// If it does, output the last tmp buffer var on the stack
					if(is_block_end && hasTmpBufferVar)
					{

						// the block at this level should be printed
						if(sawBlockEnd())
						{
							outdent();
							push_line(`__buff.put(%s);`.format(popTmpBufferVar()));
						}
					}
				}

				// remove up to the closing delimer
				prevTempl.munchHeadOf(
					temple_str,
					cDelimPos.pos + cDelim.toString().length);
			}
			else
			{
				// Move ahead to the next open delimer, rendering
				// everything between here and there as a string literal
				push_linenum();
				immutable delim_pos = oDelimPos.pos;
				push_string_literal(temple_str[0..delim_pos]);
				prevTempl.munchHeadOf(temple_str, delim_pos);
			}
		}

		// count the number of newlines in the previous part of the template;
		// that's the current line number
		line_number = prevTempl.count('\n');
	}

	outdent();
	push_line("}");
	outdent();
	push_line("}");

	return function_str;
}

template Temple(
	string template_string,
	string temple_name = "InlineTemplate")
{
	const temple_fun_str = gen_temple_func_string(
		template_string,
		temple_name);
	//pragma(msg, temple_fun_str);

	#line 1 "TempleFunc"
	mixin(temple_fun_str);
	#line 367 "src/temple/temple.d"

	alias Temple = TempleFunc;
}

template Temple(
	__FilterPolicy,
	string template_string,
	string temple_name = "InlineTemplate")
{
	static assert(!is(__FilterPolicy == void), "FilterPolicy can't be void");

	const temple_fun_str = gen_temple_func_string(
		template_string,
		temple_name,
		"__FilterPolicy");
	//pragma(msg, temple_fun_str);

	#line 1 "TempleFunc"
	mixin(temple_fun_str);
	#line 387 "src/temple/temple.d"

	alias Temple = TempleFunc!__FilterPolicy;
}

alias TempleFuncType = typeof(Temple!("", ""));

template TempleFile(string template_file)
{
	pragma(msg, "Compiling ", template_file, "...");
	alias TempleFile = Temple!(import(template_file), template_file);
}

template TempleFile(FilterPolicy, string template_file)
{
	pragma(msg, "Compiling ", template_file, "...");
	alias TempleFile = Temple!(FilterPolicy, import(template_file), template_file);
}

template TempleLayout(string template_string)
{
	alias layout_renderer = Temple!template_string;
	alias TempleLayout = TempleLayoutImpl!layout_renderer;
}

template TempleLayout(FilterPolicy, string template_string)
{
	alias layout_renderer = Temple!(FilterPolicy, template_string);
	alias TempleLayout = TempleLayoutImpl!layout_renderer;
}

template TempleLayoutFile(string template_file)
{
	alias layout_renderer = TempleFile!template_file;
	alias TempleLayoutFile = TempleLayoutImpl!layout_renderer;
}

template TempleLayoutFile(FilterPolicy, string template_file)
{
	alias layout_renderer = TempleFile!(FilterPolicy, template_file);
	alias TempleLayoutFile = TempleLayoutImpl!layout_renderer;
}

void TempleLayoutImpl(alias layout_renderer)(
	OutputStream buff,
	TempleFuncType* temple_func,
	TempleContext context = null)
{
	if(context is null)
	{
		context = new TempleContext();
	}

	auto old_partial = context.partial;
	context.partial = temple_func;
	scope(exit)
	{
		context.partial = old_partial;
	}

	layout_renderer(buff, context);
}

alias TempleLayoutFuncType = typeof(TempleLayoutImpl!(Temple!("", "")));

/**
 * Helper functions for quicly rendering a template as a string
 */

string templeToString(TempleFuncType* func, TempleContext context = null)
{
	auto accum = new AppenderOutputStream;
	(*func)(accum, context);
	return accum.data;
}

string templeToString(TempleLayoutFuncType* layout, TempleFuncType* partial, TempleContext context = null)
{
	auto accum = new AppenderOutputStream;
	(*layout)(accum, partial, context);
	return accum.data;
}

//// std.variant needs to be made CTFE compatible
//version(none)
//unittest
//{
//	alias render = Temple!q{
//		Name: <%= var.name %>
//		Number: <%= var.number %>

//		<% auto captured = capture(() { %>
//			Here is some captured content!
//			var.name: <%= var.name %>
//		<% }); %>
//		<%= captured %>

//		<%= capture(() { %>
//			A capture directly being rendered, for completeness.
//		<% }); %>
//	};

//	// The lambda is a hack to set up a temple context
//	// at compile time, using a self executing function literal

//	const result = templeToString(&render, (() {
//		auto ctx = new TempleContext;
//		ctx.name = "dymk";
//		ctx.number = 1234;
//		return ctx;
//	})() );

//	static assert(isSameRender(result, `
//		Name: dymk
//		Number: 1234
//			Here is some captured content!
//			var.name: dymk
//		A capture directly being rendered, for completeness.
//	`));
//}

